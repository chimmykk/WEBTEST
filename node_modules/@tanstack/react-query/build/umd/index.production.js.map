{"version":3,"file":"index.production.js","sources":["../../../query-core/build/esm/index.js","../../src/QueryClientProvider.tsx","../../src/isRestoring.tsx","../../src/QueryErrorResetBoundary.tsx","../../src/utils.ts","../../src/useBaseQuery.ts","../../src/Hydrate.tsx","../../src/useMutation.ts","../../src/useInfiniteQuery.ts","../../src/useIsFetching.ts","../../src/useIsMutating.ts","../../src/useQueries.ts","../../src/useQuery.ts"],"sourcesContent":["/**\n * query-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nclass Subscribable {\n  constructor() {\n    this.listeners = [];\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    this.listeners.push(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== listener);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.length > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\n// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined';\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => array2.indexOf(x) === -1);\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    this.focused = focused;\n\n    if (focused) {\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\nconst focusManager = new FocusManager();\n\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        window.addEventListener('online', listener, false);\n        window.addEventListener('offline', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener);\n          window.removeEventListener('offline', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    this.online = online;\n\n    if (online) {\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\nconst onlineManager = new OnlineManager();\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value);\n        }\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn == null ? void 0 : continueFn();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nconst defaultLogger = console;\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\nclass Removable {\n  destroy() {\n    this.clearGcTimeout();\n  }\n\n  scheduleGc() {\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime);\n    }\n  }\n\n  updateCacheTime(newCacheTime) {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);\n  }\n\n  clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  }\n\n}\n\n// CLASS\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState$1(this.options);\n    this.state = this.initialState;\n    this.meta = config.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.meta = options == null ? void 0 : options.meta;\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn');\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n      meta: this.meta\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on2, _this$cache$config2;\n\n        if (typeof data === 'undefined') {\n          onError(new Error('Query data cannot be undefined'));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: () => {\n        this.dispatch({\n          type: 'failed'\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: state.fetchFailureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState$1(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasInitialData = typeof options.initialData !== 'undefined';\n  const initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  const hasData = typeof data !== 'undefined';\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\n\n// CLASS\nclass QueryCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.queries = [];\n    this.queriesMap = {};\n  }\n\n  build(client, options, state) {\n    var _options$queryHash;\n\n    const queryKey = options.queryKey;\n    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n        meta: options.meta\n      });\n      this.add(query);\n    }\n\n    return query;\n  }\n\n  add(query) {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query;\n      this.queries.push(query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n\n  remove(query) {\n    const queryInMap = this.queriesMap[query.queryHash];\n\n    if (queryInMap) {\n      query.destroy();\n      this.queries = this.queries.filter(x => x !== query);\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash];\n      }\n\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n\n  get(queryHash) {\n    return this.queriesMap[queryHash];\n  }\n\n  getAll() {\n    return this.queries;\n  }\n\n  find(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.queries.find(query => matchQuery(filters, query));\n  }\n\n  findAll(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  onFocus() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n\n  onOnline() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n\n}\n\n// CLASS\nclass Mutation extends Removable {\n  constructor(config) {\n    super();\n    this.options = { ...config.defaultOptions,\n      ...config.options\n    };\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.logger = config.logger || defaultLogger;\n    this.observers = [];\n    this.state = config.state || getDefaultState();\n    this.meta = config.meta;\n    this.updateCacheTime(this.options.cacheTime);\n    this.scheduleGc();\n  }\n\n  setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state\n    });\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the mutation from being garbage collected\n\n      this.clearGcTimeout();\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    this.observers = this.observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n\n  optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc();\n      } else {\n        this.mutationCache.remove(this);\n      }\n    }\n  }\n\n  continue() {\n    if (this.retryer) {\n      this.retryer.continue();\n      return this.retryer.promise;\n    }\n\n    return this.execute();\n  }\n\n  async execute() {\n    const executeMutation = () => {\n      var _this$options$retry;\n\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found');\n          }\n\n          return this.options.mutationFn(this.state.variables);\n        },\n        onFail: () => {\n          this.dispatch({\n            type: 'failed'\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.retryer.promise;\n    };\n\n    const restored = this.state.status === 'loading';\n\n    try {\n      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$options$onSettl, _this$options3;\n\n      if (!restored) {\n        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n\n        this.dispatch({\n          type: 'loading',\n          variables: this.options.variables\n        }); // Notify cache callback\n\n        (_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this);\n        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables\n          });\n        }\n      }\n\n      const data = await executeMutation(); // Notify cache callback\n\n      (_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this);\n      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));\n      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n      this.dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        var _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onError, _this$options4, _this$options$onSettl2, _this$options5;\n\n        // Notify cache callback\n        (_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, error, this.state.variables, this.state.context, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n\n        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));\n        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n        throw error;\n      } finally {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            failureCount: state.failureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            isPaused: true\n          };\n\n        case 'continue':\n          return { ...state,\n            isPaused: false\n          };\n\n        case 'loading':\n          return { ...state,\n            context: action.context,\n            data: undefined,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n\n        case 'error':\n          return { ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            isPaused: false,\n            status: 'error'\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\n// CLASS\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined,\n      meta: options.meta\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return this.mutations;\n  }\n\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n    return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n  }\n\n}\n\nfunction infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject('Missing queryFn'));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n}\n\n// CLASS\nclass QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n  }\n\n  mount() {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n  }\n\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}\n\nclass QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this\n      });\n    }\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    return this.createResult(query, options);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  }\n\n  clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdateCount && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            placeholderData = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = placeholderData;\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading: status === 'loading',\n      isSuccess: status === 'success',\n      isError: status === 'error',\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching: isFetching,\n      isRefetching: isFetching && status !== 'loading',\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n\n      if (notifyOnChangeProps === 'all' || !notifyOnChangeProps && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}\n\nclass QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObservers.find(observer => observer.options.queryHash === defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = matchingObservers.map(match => match.defaultedQueryOptions.queryHash);\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.includes(defaultedOptions.queryHash));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObservers.some(match => match.observer === prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result);\n      });\n    });\n  }\n\n}\n\nclass InfiniteQueryObserver extends QueryObserver {\n  // Type override\n  // Type override\n  // Type override\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    super.setOptions({ ...options,\n      behavior: infiniteQueryBehavior()\n    }, notifyOptions);\n  }\n\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n\n  fetchNextPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'forward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'backward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  createResult(query, options) {\n    var _state$data, _state$data2, _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet;\n\n    const {\n      state\n    } = query;\n    const result = super.createResult(query, options);\n    return { ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),\n      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),\n      isFetchingNextPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === 'forward',\n      isFetchingPreviousPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === 'backward'\n    };\n  }\n\n}\n\n// CLASS\nclass MutationObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.updateResult();\n  }\n\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  setOptions(options) {\n    const prevOptions = this.options;\n    this.options = this.client.defaultMutationOptions(options);\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      var _this$currentMutation;\n\n      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.removeObserver(this);\n    }\n  }\n\n  onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    const notifyOptions = {\n      listeners: true\n    };\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    this.notify(notifyOptions);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  }\n\n  mutate(variables, options) {\n    this.mutateOptions = options;\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    });\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  }\n\n  updateResult() {\n    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n    const result = { ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n    this.currentResult = result;\n  }\n\n  notify(options) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions) {\n        if (options.onSuccess) {\n          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;\n\n          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);\n        } else if (options.onError) {\n          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;\n\n          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n\n      if (options.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      }\n    });\n  }\n\n}\n\n// TYPES\n// FUNCTIONS\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\n\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\n\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\n\nfunction dehydrate(client, options = {}) {\n  const mutations = [];\n  const queries = [];\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(mutation => {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(query => {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const mutations = dehydratedState.mutations || []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(dehydratedMutation => {\n    var _options$defaultOptio;\n\n    mutationCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations),\n      mutationKey: dehydratedMutation.mutationKey\n    }, dehydratedMutation.state);\n  });\n  queries.forEach(dehydratedQuery => {\n    var _options$defaultOptio2;\n\n    const query = queryCache.get(dehydratedQuery.queryHash); // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state);\n      }\n\n      return;\n    } // Restore query\n\n\n    queryCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries),\n      queryKey: dehydratedQuery.queryKey,\n      queryHash: dehydratedQuery.queryHash\n    }, dehydratedQuery.state);\n  });\n}\n\nexport { CancelledError, InfiniteQueryObserver, MutationCache, MutationObserver, QueriesObserver, QueryCache, QueryClient, QueryObserver, dehydrate, focusManager, hashQueryKey, hydrate, isCancelledError, isError, notifyManager, onlineManager, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react'\n\nimport { QueryClient } from '@tanstack/query-core'\nimport { ContextOptions } from './types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean,\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext)),\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","import * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","import * as React from 'react'\n\n// CONTEXT\n\ninterface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport { QueryKey, notifyManager, QueryObserver } from '@tanstack/query-core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseBaseQueryOptions } from './types'\nimport { shouldThrowError } from './utils'\nimport { useIsRestoring } from './isRestoring'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError,\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess,\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled,\n    )\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false\n    }\n  }\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (\n    defaultedOptions.suspense &&\n    result.isLoading &&\n    result.isFetching &&\n    !isRestoring\n  ) {\n    throw observer\n      .fetchOptimistic(defaultedOptions)\n      .then(({ data }) => {\n        defaultedOptions.onSuccess?.(data as TData)\n        defaultedOptions.onSettled?.(data, null)\n      })\n      .catch((error) => {\n        errorResetBoundary.clearReset()\n        defaultedOptions.onError?.(error)\n        defaultedOptions.onSettled?.(undefined, error)\n      })\n  }\n\n  // Handle error boundary\n  if (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(defaultedOptions.useErrorBoundary, [\n      result.error,\n      observer.getCurrentQuery(),\n    ])\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","import * as React from 'react'\n\nimport { hydrate, HydrateOptions } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { ContextOptions } from './types'\n\nexport function useHydrate(\n  state: unknown,\n  options: HydrateOptions & ContextOptions = {},\n) {\n  const queryClient = useQueryClient({ context: options.context })\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization.\n  // hydrate can and should be run *during* render here for SSR to work properly\n  React.useMemo(() => {\n    if (state) {\n      hydrate(queryClient, state, optionsRef.current)\n    }\n  }, [queryClient, state])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n  options?: HydrateOptions\n  children?: React.ReactNode\n}\n\nexport const Hydrate = ({ children, options, state }: HydrateProps) => {\n  useHydrate(state, options)\n  return children as React.ReactElement\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  notifyManager,\n  parseMutationArgs,\n  MutationObserver,\n  MutationFunction,\n  MutationKey,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport { shouldThrowError } from './utils'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","import {\n  QueryObserver,\n  InfiniteQueryObserver,\n  QueryFunction,\n  QueryKey,\n  parseQueryArgs,\n} from '@tanstack/query-core'\nimport { UseInfiniteQueryOptions, UseInfiniteQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey' | 'queryFn'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1:\n    | TQueryKey\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg3?: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError> {\n  const options = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(\n    options,\n    InfiniteQueryObserver as typeof QueryObserver,\n  ) as UseInfiniteQueryResult<TData, TError>\n}\n","import * as React from 'react'\nimport {\n  QueryKey,\n  notifyManager,\n  parseFilterArgs,\n  QueryFilters,\n} from '@tanstack/query-core'\n\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\nimport { ContextOptions } from './types'\nimport { useQueryClient } from './QueryClientProvider'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsFetching(filters?: QueryFilters, options?: Options): number\nexport function useIsFetching(\n  queryKey?: QueryKey,\n  filters?: QueryFilters,\n  options?: Options,\n): number\nexport function useIsFetching(\n  arg1?: QueryKey | QueryFilters,\n  arg2?: QueryFilters | Options,\n  arg3?: Options,\n): number {\n  const [filters, options = {}] = parseFilterArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n  const queryCache = queryClient.getQueryCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache],\n    ),\n    () => queryClient.isFetching(filters),\n    () => queryClient.isFetching(filters),\n  )\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  notifyManager,\n  MutationKey,\n  MutationFilters,\n  parseMutationFilterArgs,\n} from '@tanstack/query-core'\nimport { ContextOptions } from './types'\nimport { useQueryClient } from './QueryClientProvider'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsMutating(\n  filters?: MutationFilters,\n  options?: Options,\n): number\nexport function useIsMutating(\n  mutationKey?: MutationKey,\n  filters?: Omit<MutationFilters, 'mutationKey'>,\n  options?: Options,\n): number\nexport function useIsMutating(\n  arg1?: MutationKey | MutationFilters,\n  arg2?: Omit<MutationFilters, 'mutationKey'> | Options,\n  arg3?: Options,\n): number {\n  const [filters, options = {}] = parseMutationFilterArgs(arg1, arg2, arg3)\n\n  const queryClient = useQueryClient({ context: options.context })\n  const mutationCache = queryClient.getMutationCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        mutationCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [mutationCache],\n    ),\n    () => queryClient.isMutating(filters),\n    () => queryClient.isMutating(filters),\n  )\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  QueryKey,\n  QueryFunction,\n  notifyManager,\n  QueriesObserver,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseQueryOptions, UseQueryResult } from './types'\nimport { useIsRestoring } from './isRestoring'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'context'>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        unknown,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? UseQueryResult<TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...QueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): QueriesResults<T> {\n  const queryClient = useQueryClient({ context })\n  const isRestoring = useIsRestoring()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((options) => {\n        const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, queryClient, isRestoring],\n  )\n\n  const [observer] = React.useState(\n    () => new QueriesObserver(queryClient, defaultedQueries),\n  )\n\n  const result = observer.getOptimisticResult(defaultedQueries)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries, observer])\n\n  return result as QueriesResults<T>\n}\n","import {\n  parseQueryArgs,\n  QueryFunction,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport { DefinedUseQueryResult, UseQueryOptions, UseQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(parsedOptions, QueryObserver)\n}\n"],"names":["Subscribable","constructor","this","listeners","subscribe","bind","listener","push","onSubscribe","filter","x","onUnsubscribe","hasListeners","length","isServer","window","noop","isValidTimeout","value","Infinity","difference","array1","array2","indexOf","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","parseMutationArgs","mutationKey","mutationFn","parseFilterArgs","parseMutationFilterArgs","matchQuery","filters","query","type","exact","fetchStatus","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","fetching","hashQueryKey","status","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","partialDeepEqual","some","replaceEqualDeep","array","isPlainArray","aSize","bItems","bSize","copy","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","call","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","replaceData","prevData","data","isDataEqual","structuralSharing","focusManager","super","setup","onFocus","addEventListener","removeEventListener","cleanup","setEventListener","_this$cleanup","undefined","_this$cleanup2","focused","setFocused","forEach","isFocused","document","includes","visibilityState","onlineManager","onOnline","online","setOnline","isOnline","navigator","onLine","defaultRetryDelay","failureCount","min","canFetch","networkMode","CancelledError","revert","silent","isCancelledError","createRetryer","config","continueFn","promiseResolve","promiseReject","isRetryCancelled","isResolved","promise","outerResolve","outerReject","shouldPause","onSuccess","reject","onError","pause","continueResolve","onPause","onContinue","run","promiseOrValue","fn","error","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","cancel","cancelOptions","abort","continue","cancelRetry","continueRetry","defaultLogger","console","notifyManager","queue","transactions","notifyFn","batchNotifyFn","schedule","flush","originalQueue","batch","batchCalls","args","setNotifyFunction","setBatchNotifyFunction","createNotifyManager","Removable","destroy","clearGcTimeout","scheduleGc","cacheTime","gcTimeout","optionalRemove","updateCacheTime","newCacheTime","clearTimeout","Query","abortSignalConsumed","defaultOptions","setOptions","observers","cache","logger","initialState","initialData","initialDataUpdatedAt","hasData","dataUpdateCount","dataUpdatedAt","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchMeta","isInvalidated","getDefaultState$1","meta","remove","setData","newData","dispatch","manual","setState","setStateOptions","_this$retryer","retryer","reset","observer","enabled","isDisabled","getObserversCount","getCurrentResult","isStaleByTime","_this$retryer2","find","shouldFetchOnWindowFocus","refetch","cancelRefetch","_this$retryer3","shouldFetchOnReconnect","addObserver","notify","removeObserver","invalidate","fetch","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","abortController","AbortController","getAbortController","queryFnContext","pageParam","addSignalProperty","object","defineProperty","enumerable","get","signal","context","fetchFn","_context$fetchOptions2","behavior","onFetch","revertState","_this$cache$config$on","_this$cache$config","isFetchingOptimistic","_this$cache$config$on2","_this$cache$config2","Error","action","_action$meta","_action$dataUpdatedAt","reducer","onQueryUpdate","QueryCache","queries","queriesMap","build","client","_options$queryHash","getLogger","defaultQueryOptions","getQueryDefaults","add","queryInMap","clear","getAll","findAll","event","Mutation","mutationId","mutationCache","getDefaultState","execute","async","executeMutation","_this$options$retry","variables","restored","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$options$onSettl","_this$options3","_this$mutationCache$c","_this$mutationCache$c2","_this$options$onMutat","_this$options","onMutate","onSettled","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onError","_this$options4","_this$options$onSettl2","_this$options5","isPaused","onMutationUpdate","MutationCache","mutations","defaultMutationOptions","getMutationDefaults","resumePausedMutations","pausedMutations","infiniteQueryBehavior","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","cancelled","buildNewPages","param","page","previous","fetchPage","_context$signal","_context$signal2","aborted","queryFnResult","getNextPageParam","getPreviousPageParam","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","QueryObserver","trackedProps","Set","selectError","bindMethods","currentQuery","shouldFetchOnMount","executeFetch","updateTimers","shouldFetchOn","refetchOnReconnect","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","notifyOptions","prevOptions","prevQuery","getQueryCache","updateQuery","mounted","shouldFetchOptionally","updateResult","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","createResult","currentResult","trackResult","trackedResult","configurable","getCurrentQuery","fetchOptimistic","defaultedOptions","_fetchOptions$cancelR","throwOnError","staleTimeoutId","_this$options$refetch","refetchInterval","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearInterval","prevResult","prevResultState","currentResultState","prevResultOptions","currentResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","isPreviousData","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","keepPreviousData","isSuccess","select","selectFn","selectResult","placeholderData","isFetching","isLoading","isError","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","nextResult","defaultNotifyOptions","notifyOnChangeProps","size","includedProps","useErrorBoundary","typedKey","has","shouldNotifyListeners","retryOnMount","shouldLoadOnMount","refetchOnMount","field","suspense","QueriesObserver","observersMap","setQueries","onUpdate","prevObservers","newObserverMatches","findMatchingObservers","match","defaultedQueryOptions","newObservers","map","newObserversMap","fromEntries","newResult","hasIndexChange","index","matchingObservers","flatMap","matchedQueryHashes","unmatchedQueries","unmatchedObservers","prevObserver","getObserver","currentObserver","newOrReusedObservers","previouslyUsedObserver","concat","slice","replaceAt","InfiniteQueryObserver","fetchNextPage","fetchPreviousPage","_state$data","_state$data2","_state$fetchMeta","_state$fetchMeta$fetc","_state$fetchMeta2","_state$fetchMeta2$fet","MutationObserver","mutate","getMutationCache","currentMutation","_this$currentMutation","mutateOptions","isIdle","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","defaultShouldDehydrateMutation","defaultShouldDehydrateQuery","hydrate","dehydratedState","queryCache","dehydratedMutation","_options$defaultOptio","dehydratedQuery","_options$defaultOptio2","defaultContext","React","createContext","QueryClientSharingContext","getQueryClientContext","contextSharing","ReactQueryClientContext","useQueryClient","queryClient","useContext","IsRestoringContext","useIsRestoring","IsRestoringProvider","Provider","createValue","isReset","clearReset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","shouldThrowError","_useErrorBoundary","params","useBaseQuery","Observer","isRestoring","errorResetBoundary","useState","useSyncExternalStore","useCallback","onStoreChange","useEffect","useHydrate","optionsRef","useRef","current","useMemo","children","queryDefaults","mutationDefaults","mount","unsubscribeFocus","unsubscribeOnline","unmount","_this$unsubscribeFocu","_this$unsubscribeOnli","isMutating","getQueryData","_this$queryCache$find","getQueriesData","queryKeyOrFilters","setQueryData","updater","input","functionalUpdate","parsedOptions","setQueriesData","getQueryState","_this$queryCache$find2","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","promises","all","invalidateQueries","_ref","_filters$refetchType","refetchType","_options$cancelRefetc","fetchQuery","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","getDefaultOptions","setDefaultOptions","setQueryDefaults","firstMatchingDefaults","setMutationDefaults","_defaulted","Context","createElement","dehydrateMutations","shouldDehydrateMutation","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","dehydrateQuery","mutateAsync","defaultedQueries"],"mappings":"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"}