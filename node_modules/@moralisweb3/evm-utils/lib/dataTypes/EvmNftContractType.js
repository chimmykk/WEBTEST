"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateValidEvmContractType = exports.isValidEvmContractType = exports.EvmNftContractType = void 0;
var core_1 = require("@moralisweb3/core");
var EvmNftContractType;
(function (EvmNftContractType) {
    EvmNftContractType["ERC721"] = "ERC721";
    EvmNftContractType["ERC1155"] = "ERC1155";
})(EvmNftContractType = exports.EvmNftContractType || (exports.EvmNftContractType = {}));
var isValidEvmContractType = function (value) {
    switch (value.toUpperCase()) {
        case EvmNftContractType.ERC1155:
            return true;
        case EvmNftContractType.ERC721:
            return true;
        default:
            false;
    }
    return false;
};
exports.isValidEvmContractType = isValidEvmContractType;
var validateValidEvmContractType = function (value) {
    if (!(0, exports.isValidEvmContractType)(value)) {
        throw new core_1.MoralisCoreError({
            code: core_1.CoreErrorCode.INVALID_ARGUMENT,
            message: 'Invalid NFT contract type provided',
        });
    }
    return value;
};
exports.validateValidEvmContractType = validateValidEvmContractType;
//# sourceMappingURL=EvmNftContractType.js.map