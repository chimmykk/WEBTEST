"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MoralisState = void 0;
var fsm_1 = require("@xstate/fsm");
var Error_1 = require("../Error");
var MoralisState = /** @class */ (function () {
    function MoralisState(name) {
        this.name = name;
        this.value = null;
    }
    Object.defineProperty(MoralisState.prototype, "isStarted", {
        get: function () {
            if (!this.value) {
                return false;
            }
            return true;
        },
        enumerable: false,
        configurable: true
    });
    MoralisState.prototype.assertStarted = function () {
        var value = this.value;
        if (!value || !this.isStarted) {
            throw new Error_1.MoralisCoreError({
                code: Error_1.CoreErrorCode.STATE_MACHINE_NOT_STARTED,
                message: "State machine \"".concat(this.name, "\" not started. Call moralisState.start() first."),
            });
        }
        return value;
    };
    MoralisState.prototype.start = function (_config) {
        if (this.isStarted) {
            throw new Error_1.MoralisCoreError({
                code: Error_1.CoreErrorCode.STATE_MACHINE_STARTED,
                message: "State machine \"".concat(this.name, "\" already started."),
            });
        }
        var config = __assign({ id: this.name }, _config);
        var machine = (0, fsm_1.createMachine)(config);
        var service = (0, fsm_1.interpret)(machine).start();
        this.value = {
            config: config,
            machine: machine,
            service: service,
        };
        return this.value;
    };
    Object.defineProperty(MoralisState.prototype, "state", {
        get: function () {
            var value = this.assertStarted();
            return value.service.state;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MoralisState.prototype, "machine", {
        get: function () {
            var value = this.assertStarted();
            return value.machine;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MoralisState.prototype, "service", {
        get: function () {
            var value = this.assertStarted();
            return value.service;
        },
        enumerable: false,
        configurable: true
    });
    MoralisState.prototype.match = function (value) {
        this.assertStarted();
        return this.state.matches(value);
    };
    // Optimistic check if state can change
    // Note: this takes no guards into account at all, it only checks the config definition
    // to see if there is an event of the type defined
    MoralisState.prototype.can = function (event) {
        var state = this.state.value;
        var stateConfig = this.machine.config.states[state];
        var ons = stateConfig.on;
        return ons && Object.keys(ons).includes(event);
    };
    MoralisState.prototype.transition = function (event) {
        var value = this.assertStarted();
        return value.service.send(event);
    };
    return MoralisState;
}());
exports.MoralisState = MoralisState;
//# sourceMappingURL=MoralisState.js.map